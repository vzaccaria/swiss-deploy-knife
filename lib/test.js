// Generated by LiveScript 1.2.0
(function(){
  var should, sinon, assert, _, moment, __q, winston, dispOk, dispKo, disp, pdisp, pdeb, notifiesOnFail, notifiesOnSuccess, createResolvedPromise, createRejectedPromise, psetup, patchDependency, unpatchDependency;
  should = require('should');
  sinon = require('sinon');
  assert = require('assert');
  _ = require('underscore');
  moment = require('moment');
  __q = require('q');
  winston = require('winston');
  dispOk = function(){
    return winston.info("Ok");
  };
  dispKo = function(it){
    return winston.error(it != null ? it.toString() : void 8);
  };
  disp = winston.info;
  pdisp = console.log;
  pdeb = winston.warn;
  notifiesOnFail = function(p, cb){
    return p.then(dispKo, function(){
      return cb();
    });
  };
  notifiesOnSuccess = function(p, cb){
    return p.then(function(){
      return cb();
    }, dispKo);
  };
  createResolvedPromise = function(){
    var d, p;
    d = __q.defer();
    p = d.promise;
    d.resolve();
    return p;
  };
  createRejectedPromise = function(){
    var d, p;
    d = __q.defer();
    p = d.promise;
    d.reject();
    return p;
  };
  psetup = function(file){
    if (file != null) {
      winston.add(winston.transports.File, {
        filename: file
      });
      return winston.remove(winston.transports.Console);
    } else {
      winston.remove(winston.transports.Console);
      return winston.add(winston.transports.Console, {
        level: 'error',
        colorize: true
      });
    }
  };
  patchDependency = curry$(function(module, depname, property, value){
    return sinon.stub(module.innerModule()[depname], property, value);
  });
  unpatchDependency = curry$(function(module, depname, property){
    var i$, len$, e, results$ = [];
    if (!_.isArray(property)) {
      return module.innerModule()[depname][property].restore();
    } else {
      for (i$ = 0, len$ = property.length; i$ < len$; ++i$) {
        e = property[i$];
        results$.push(module.innerModule()[depname][e].restore());
      }
      return results$;
    }
  });
  psetup();
  describe('ssh command-on-wire connection', function(empty){
    var mod, conn, mockConn, targetModule;
    it('should instantiate connection module module', function(){
      mod = require('./connect');
      return should.exist(mod);
    });
    it('should create a connection `conn`', function(){
      conn = mod.createConnection();
      return should.exist(conn);
    });
    it('`module.connect` should call `conn.connect`', function(){
      var expected, s1;
      expected = sinon.mock(conn).expects('connect').once();
      s1 = sinon.stub(mod.innerModule(), 'otherGetCredentials', function(){});
      mod.connect(conn, {
        credentials: '/Users/zaccaria/.ssh/id_sa'
      });
      expected.verify();
      return s1.calledOnce.should.be.equal(true);
    });
    it('`module.send-command` should call `conn.exec` and get a succesful promise', function(done){
      var fakeStream, p;
      fakeStream = new (require('events').EventEmitter)();
      sinon.stub(conn, 'exec', function(c, cb){
        return cb(null, fakeStream);
      });
      p = mod.sendCommand(conn, "df");
      fakeStream.emit('data', "fake output");
      fakeStream.emit('exit', 0, 0);
      p.then(function(){
        return done();
      });
      return conn.exec.restore();
    });
    it('`module.send-command` should call `conn.exec` and get a unsuccesful promise (command fails)', function(done){
      var fakeStream, p;
      fakeStream = new (require('events').EventEmitter)();
      sinon.stub(conn, 'exec', function(c, cb){
        return cb(null, fakeStream);
      });
      p = mod.sendCommand(conn, "df");
      fakeStream.emit('data', "fake output");
      fakeStream.emit('exit', 1, 0);
      p.fail(function(){
        return done();
      });
      return conn.exec.restore();
    });
    it('`module.send-command` should call `conn.exec` and get a unsuccessful promise (command does not exist)', function(done){
      var p;
      sinon.stub(conn, 'exec', function(c, cb){
        return cb(true, null);
      });
      p = mod.sendCommand(conn, "df");
      p.fail(function(){
        return done();
      });
      return conn.exec.restore();
    });
    return it('`module.send-command` should call `conn.exec` and get a unsuccesful promise (stream generates an error)', function(done){
      var fakeStream, p;
      fakeStream = new (require('events').EventEmitter)();
      sinon.stub(conn, 'exec', function(c, cb){
        return cb(null, fakeStream);
      });
      p = mod.sendCommand(conn, "df");
      conn.emit('error');
      p.fail(function(){
        return done();
      });
      return conn.exec.restore();
    });
  });
  describe('actions', function(empty){
    var act, namespace, nodes, s1, s2, s3, s4;
    act = require('./actions');
    namespace = {
      test: {
        tasks: {
          task1: {
            name: 'task1',
            fun: function(){
              var d;
              d = __q.defer();
              d.resolve('task finished');
              return d.promise;
            }
          },
          taskfail: {
            name: 'taskfail',
            fun: function(){
              var d;
              d = __q.defer();
              d.reject('task finished with error');
              return d.promise;
            }
          }
        }
      },
      test2: {
        tasks: {
          task3: {
            name: 'task3',
            fun: function(){
              var d;
              d = __q.defer();
              d.resolve('task finished');
              return d.promise;
            }
          },
          taskfail: {
            name: 'taskfail',
            fun: function(){
              var d;
              d = __q.defer();
              d.reject('task finished with error');
              return d.promise;
            }
          }
        }
      },
      test3: {
        defaultNode: 's2',
        tasks: {
          task3: {
            name: 'task3',
            fun: function(){
              var d;
              d = __q.defer();
              d.resolve('task finished');
              return d.promise;
            }
          },
          taskfail: {
            name: 'taskfail',
            fun: function(){
              var d;
              d = __q.defer();
              d.reject('task finished with error');
              return d.promise;
            }
          }
        }
      }
    };
    nodes = {
      s1: {
        description: "Hbomb",
        path: {
          username: "zaccaria",
          hostname: "hbomb.elet.polimi.it",
          port: "22",
          credentials: '/Users/zaccaria/.ssh/id_rsa',
          hosttype: 'linux',
          access: 'ssh'
        }
      },
      s2: {
        description: "Vagrant box",
        path: {
          from: 's1',
          use: 4444,
          username: "vagrant",
          hostname: "127.0.0.1",
          port: "2222",
          credentials: '/Users/zaccaria/.ssh/id_rsa',
          hosttype: 'linux',
          access: 'ssh'
        }
      }
    };
    describe('actions.direct-call', function(empty){
      it('`module.direct-call` should invoke the correct task', function(done){
        var p;
        p = createResolvedPromise();
        p = act.directCall(p, 'test', 'task1', nodes['s1'], {}, namespace, nodes);
        return notifiesOnSuccess(p, done);
      });
      it('`module.direct-call` should throw with incorrect task', function(done){
        var p;
        p = createResolvedPromise();
        p = act.directCall(p, 'test', 'task2', nodes['s1'], {}, namespace, nodes);
        return notifiesOnFail(p, done);
      });
      it('`module.direct-call` should throw with incorrect namespace', function(done){
        var p;
        p = createResolvedPromise();
        p = act.directCall(p, 'tes', 'task1', nodes['s1'], {}, namespace, nodes);
        return notifiesOnFail(p, done);
      });
      it('`module.direct-call` should throw with incorrect namespace', function(done){
        var p;
        p = createResolvedPromise();
        p = act.directCall(p, 'test', 'task1', nodes['s1'], {}, null, nodes);
        return notifiesOnFail(p, done);
      });
      it('`module.direct-call` should throw with incorrect node', function(done){
        var p;
        p = createResolvedPromise();
        p = act.directCall(p, 'test', 'task1', nodes, {}, namespace, nodes);
        return notifiesOnFail(p, done);
      });
      return it('`module.direct-call` should throw with incorrect nodes', function(done){
        var p;
        p = createResolvedPromise();
        p = act.directCall(p, 'test', 'task1', nodes['s1'], {}, namespace, null);
        return notifiesOnFail(p, done);
      });
    });
    describe('actions.indirect-call', function(empty){
      it('`module.indirect-call` should invoke the correct task', function(done){
        var p;
        sinon.stub(act.innerModule().tunnel, 'mountTunnel', createResolvedPromise);
        sinon.stub(act.innerModule().tunnel, 'unmountTunnel', createResolvedPromise);
        p = createResolvedPromise();
        p = act.indirectCall(p, 'test', 'task1', nodes['s2'], {}, namespace, nodes);
        return notifiesOnSuccess(p, done);
      });
      it('`module.indirect-call` should not invoke the correct task on a directly accessible node', function(done){
        var p;
        p = createResolvedPromise();
        p = act.indirectCall(p, 'test', 'task1', nodes['s1'], {}, namespace, nodes);
        return notifiesOnFail(p, done);
      });
      it('`module.indirect-call` should throw with incorrect task', function(done){
        var p;
        p = createResolvedPromise();
        p = act.directCall(p, 'test', 'task2', nodes['s2'], {}, namespace, nodes);
        return notifiesOnFail(p, done);
      });
      it('`module.indirect-call` should throw with incorrect namespace', function(done){
        var p;
        p = createResolvedPromise();
        p = act.directCall(p, 'tes', 'task1', nodes['s2'], {}, namespace, nodes);
        return notifiesOnFail(p, done);
      });
      it('`module.indirect-call` should throw with incorrect namespace', function(done){
        var p;
        p = createResolvedPromise();
        p = act.directCall(p, 'test', 'task1', nodes['s2'], {}, null, nodes);
        return notifiesOnFail(p, done);
      });
      it('`module.indirect-call` should throw with incorrect node', function(done){
        var p;
        p = createResolvedPromise();
        p = act.directCall(p, 'test', 'task1', nodes, {}, namespace, nodes);
        return notifiesOnFail(p, done);
      });
      it('`module.indirect-call` should throw with incorrect nodes', function(done){
        var p;
        p = createResolvedPromise();
        p = act.directCall(p, 'test', 'task1', nodes['s2'], {}, namespace, null);
        return notifiesOnFail(p, done);
      });
      return it('`module.indirect-call` should return a rejected promise on failed mount', function(done){
        var p;
        act.innerModule().tunnel.mountTunnel.restore();
        act.innerModule().tunnel.unmountTunnel.restore();
        sinon.stub(act.innerModule().tunnel, 'mountTunnel', createRejectedPromise);
        sinon.stub(act.innerModule().tunnel, 'unmountTunnel', function(t, p){
          return p;
        });
        p = createResolvedPromise();
        p = act.indirectCall(p, 'test', 'task1', nodes['s2'], {}, namespace, nodes);
        return notifiesOnFail(p, done);
      });
    });
    return describe('actions.invoke-actions', function(empty){
      it('should invoke the correct task', function(done){
        var p;
        act.innerModule().tunnel.mountTunnel.restore();
        act.innerModule().tunnel.unmountTunnel.restore();
        sinon.stub(act.innerModule().tunnel, 'mountTunnel', createResolvedPromise);
        sinon.stub(act.innerModule().tunnel, 'unmountTunnel', createResolvedPromise);
        p = createResolvedPromise();
        p = act.invokeActions(p, 's1', {
          _: ['test:task1']
        }, nodes, namespace);
        return notifiesOnSuccess(p, done);
      });
      it('should invoke the correct task', function(done){
        var p;
        act.innerModule().tunnel.mountTunnel.restore();
        act.innerModule().tunnel.unmountTunnel.restore();
        sinon.stub(act.innerModule().tunnel, 'mountTunnel', createResolvedPromise);
        sinon.stub(act.innerModule().tunnel, 'unmountTunnel', createResolvedPromise);
        p = createResolvedPromise();
        p = act.invokeActions(p, 's1', {
          namespace: 'test',
          _: ['task1']
        }, nodes, namespace);
        return notifiesOnSuccess(p, done);
      });
      it('should not invoke a non-existing task', function(done){
        var p;
        p = createResolvedPromise();
        p = act.invokeActions(p, 's1', {
          _: ['tes:task1']
        }, nodes, namespace);
        return notifiesOnFail(p, done);
      });
      it('should fail on failing task', function(done){
        var p;
        p = createResolvedPromise();
        p = act.invokeActions(p, 's1', {
          _: ['test:task2']
        }, nodes, namespace);
        return notifiesOnFail(p, done);
      });
      it('should fail on non-existing node', function(done){
        var p;
        p = createResolvedPromise();
        p = act.invokeActions(p, 's', {
          _: ['test:task1']
        }, nodes, namespace);
        return notifiesOnFail(p, done);
      });
      it('should fail on incorrect params', function(done){
        var p;
        p = createResolvedPromise();
        p = act.invokeActions(p, 's', {
          _: ['test:task1']
        }, null, namespace);
        return notifiesOnFail(p, done);
      });
      it('should fail on incorrect params', function(done){
        var p;
        p = createResolvedPromise();
        p = act.invokeActions(p, 's', {
          _: ['test:task1']
        }, nodes, null);
        return notifiesOnFail(p, done);
      });
      it('if first task fails, do not execute the second one', function(done){
        var p;
        s1 = sinon.spy(namespace['test'].tasks['task1'], 'fun');
        s2 = sinon.spy(namespace['test'].tasks['taskfail'], 'fun');
        p = createResolvedPromise();
        p = act.invokeActions(p, 's1', {
          _: ['test:taskfail', 'test:task1']
        }, nodes, namespace);
        p = p.fail(function(){
          assert(s2.calledOnce);
          return assert(!s1.calledOnce);
        });
        return notifiesOnSuccess(p, done);
      });
      it('if first task does not exist, do not execute the second one', function(done){
        var p;
        namespace['test'].tasks['task1'].fun.restore();
        namespace['test'].tasks['taskfail'].fun.restore();
        s1 = sinon.spy(namespace['test'].tasks['task1'], 'fun');
        s2 = sinon.spy(namespace['test'].tasks['taskfail'], 'fun');
        p = createResolvedPromise();
        p = act.invokeActions(p, 's1', {
          _: ['test:taskfai', 'test:task1']
        }, nodes, namespace);
        p = p.fail(function(){
          assert(!s2.calledOnce);
          return assert(!s1.calledOnce);
        });
        return notifiesOnSuccess(p, done);
      });
      it('if second task fails, execute the first one', function(done){
        var p;
        namespace['test'].tasks['task1'].fun.restore();
        namespace['test'].tasks['taskfail'].fun.restore();
        s1 = sinon.spy(namespace['test'].tasks['task1'], 'fun');
        s2 = sinon.spy(namespace['test'].tasks['taskfail'], 'fun');
        p = createResolvedPromise();
        p = act.invokeActions(p, 's1', {
          _: ['test:task1', 'test:taskfail']
        }, nodes, namespace);
        p = p.fail(function(){
          assert(s1.calledOnce);
          return assert(s2.calledOnce);
        });
        return notifiesOnSuccess(p, done);
      });
      it('should invoke the correct task when a default node is not present', function(done){
        var p;
        act.innerModule().tunnel.mountTunnel.restore();
        act.innerModule().tunnel.unmountTunnel.restore();
        sinon.stub(act.innerModule().tunnel, 'mountTunnel', createResolvedPromise);
        sinon.stub(act.innerModule().tunnel, 'unmountTunnel', createResolvedPromise);
        s3 = sinon.spy(act.innerModule(), 'indirectCall');
        s4 = sinon.spy(act.innerModule(), 'directCall');
        s1 = sinon.spy(namespace['test2'].tasks['task3'], 'fun');
        p = createResolvedPromise();
        p = act.invokeActions(p, 's1', {
          _: ['test2:task3']
        }, nodes, namespace);
        p = p.then(function(){
          assert(s4.getCall(0).args[3].description === 'Hbomb');
          assert(s4.calledOnce);
          return assert(s1.calledOnce);
        });
        return notifiesOnSuccess(p, done);
      });
      it('should invoke the correct task when a default node is present', function(done){
        var p;
        act.innerModule().tunnel.mountTunnel.restore();
        act.innerModule().tunnel.unmountTunnel.restore();
        act.innerModule().directCall.restore();
        act.innerModule().indirectCall.restore();
        sinon.stub(act.innerModule().tunnel, 'mountTunnel', createResolvedPromise);
        sinon.stub(act.innerModule().tunnel, 'unmountTunnel', createResolvedPromise);
        s3 = sinon.spy(act.innerModule(), 'indirectCall');
        s4 = sinon.spy(act.innerModule(), 'directCall');
        s1 = sinon.spy(namespace['test3'].tasks['task3'], 'fun');
        p = createResolvedPromise();
        p = act.invokeActions(p, 's1', {
          _: ['test3:task3']
        }, nodes, namespace);
        p = p.then(function(){
          assert(s3.getCall(0).args[3].description === 'Vagrant box');
          assert(s3.calledOnce);
          return assert(s1.calledOnce);
        });
        return notifiesOnSuccess(p, done);
      });
      return it('should invoke the correct task when a default node is present but forced from outside', function(done){
        var p;
        act.innerModule().tunnel.mountTunnel.restore();
        act.innerModule().tunnel.unmountTunnel.restore();
        act.innerModule().directCall.restore();
        act.innerModule().indirectCall.restore();
        sinon.stub(act.innerModule().tunnel, 'mountTunnel', createResolvedPromise);
        sinon.stub(act.innerModule().tunnel, 'unmountTunnel', createResolvedPromise);
        s3 = sinon.spy(act.innerModule(), 'indirectCall');
        s4 = sinon.spy(act.innerModule(), 'directCall');
        p = createResolvedPromise();
        p = act.invokeActions(p, 's1', {
          _: ['test3:task3'],
          node: 's1'
        }, nodes, namespace);
        p = p.then(function(){
          assert(s4.getCall(0).args[3].description === 'Hbomb');
          return assert(s4.calledOnce);
        });
        return notifiesOnSuccess(p, done);
      });
    });
  });
  describe('tasks and namespace', function(empty){
    var tsk, p, ns, spy;
    tsk = require('./task');
    ns = tsk.buildTasks([
      tsk.namespace('general', 'general commands applicable to almost all access modes', tsk.task('top', 'inspects processes', function(){
        return tsk.run(this.remote, 'top -b -n 1 | head -n 12');
      })), tsk.namespace('myns', tsk.task('xyz', function(){
        return console.log("no fun..");
      })), tsk.namespace('myns2', {
        defaultNode: 's3'
      }, tsk.task('xyz', function(){
        return console.log("no fun..");
      }))
    ]);
    describe('tasks and namespaces', function(empty){
      it('should create namespaces structure', function(){
        should.exist(ns);
        should.exist(ns['general']);
        return should.exist(ns['myns']);
      });
      it('should create tasks', function(){
        should.exist(ns['general'].tasks['top']);
        return should.exist(ns['myns'].tasks['xyz']);
      });
      it('should create metadata', function(){
        ns['general'].tasks['top'].description.should.be.equal('inspects processes');
        ns['general'].tasks['top'].name.should.be.equal('top');
        should.exist(ns['myns'].tasks['xyz'].name);
        return ns['myns'].tasks['xyz'].description.should.be.equal('');
      });
      it('should associate functions correctly', function(){
        should.exist(ns['general'].tasks['top'].fun);
        _.isFunction(ns['general'].tasks['top'].fun).should.be.equal(true);
        should.exist(ns['myns'].tasks['xyz'].fun);
        return _.isFunction(ns['myns'].tasks['xyz'].fun).should.be.equal(true);
      });
      return it('should recognize a default node', function(){
        should.exist(ns['myns2'].tasks['xyz'].fun);
        _.isFunction(ns['myns2'].tasks['xyz'].fun).should.be.equal(true);
        return ns['myns2'].defaultNode.should.be.equal('s3');
      });
    });
    describe('run', function(empty){
      var fakeConn, patchConnect, unpatchConnect, newConnection;
      patchConnect = patchDependency(tsk, 'connect');
      unpatchConnect = unpatchDependency(tsk, 'connect');
      newConnection = function(){
        var fc;
        fc = new (require('events').EventEmitter)();
        fc.end = sinon.stub().returns(true);
        fc.ok = function(){
          return fc.emit('ready');
        };
        return fc;
      };
      it('should return a rejected promise if command fails', function(done){
        fakeConn = newConnection();
        patchConnect('createConnection', function(){
          return {};
        });
        patchConnect('connect', function(){
          return fakeConn;
        });
        spy = patchConnect('sendCommand', function(){
          return createRejectedPromise();
        });
        p = tsk.run({}, 'a', {});
        fakeConn.ok();
        return notifiesOnFail(p, done);
      });
      it('should return a resolved promise', function(done){
        unpatchConnect(['createConnection', 'connect', 'sendCommand']);
        fakeConn = newConnection();
        patchConnect('createConnection', function(){
          return {};
        });
        patchConnect('connect', function(){
          return fakeConn;
        });
        spy = patchConnect('sendCommand', function(){
          return createResolvedPromise();
        });
        p = tsk.run({}, 'a', {});
        fakeConn.ok();
        return notifiesOnSuccess(p, done);
      });
      it('should send the correct command', function(){
        spy.calledOnce.should.be.equal(true);
        return spy.firstCall.args[1].should.be.equal('a');
      });
      it('should be called twice', function(done){
        fakeConn = new (require('events').EventEmitter)();
        fakeConn.end = sinon.stub().returns(true);
        p = tsk.run({}, ['b', 'c'], {});
        fakeConn.emit('ready');
        return notifiesOnSuccess(p, done);
      });
      it('should send two commands', function(){
        spy.calledThrice.should.be.equal(true);
        spy.secondCall.args[1].should.be.equal('b');
        return spy.thirdCall.args[1].should.be.equal('c');
      });
      it('run-local should interpret options', function(done){
        fakeConn = new (require('events').EventEmitter)();
        fakeConn.end = sinon.stub().returns(true);
        p = tsk.runLocal({}, ['d'], {});
        fakeConn.emit('ready');
        return notifiesOnSuccess(p, done);
      });
      it('run-local should have invoked run underneath', function(){
        return spy.lastCall.args[1].should.be.equal('d');
      });
      it('run-local should interpret options', function(done){
        var daNode;
        fakeConn = new (require('events').EventEmitter)();
        fakeConn.end = sinon.stub().returns(true);
        daNode = {
          login: {
            runAsSudo: true,
            directory: '~/test/infoweb'
          }
        };
        p = tsk.runLocal(daNode, ['a'], {});
        fakeConn.emit('ready');
        return notifiesOnSuccess(p, done);
      });
      it('run-local should have invoked run underneath', function(){
        return spy.lastCall.args[1].should.be.equal('cd ~/test/infoweb && sudo a');
      });
      it('run-local should interpret options', function(done){
        var daNode;
        fakeConn = new (require('events').EventEmitter)();
        fakeConn.end = sinon.stub().returns(true);
        daNode = {
          login: {
            shell: tsk.bsh,
            runAsSudo: false,
            directory: '~/test/infoweb'
          }
        };
        p = tsk.runLocal(daNode, ['a'], {});
        fakeConn.emit('ready');
        return notifiesOnSuccess(p, done);
      });
      it('run-local should have invoked run underneath', function(){
        return spy.lastCall.args[1].should.be.equal('bash -l -c \'cd ~/test/infoweb && a\'');
      });
      it('run-local should interpret options', function(done){
        var daNode;
        fakeConn = new (require('events').EventEmitter)();
        fakeConn.end = sinon.stub().returns(true);
        daNode = {
          login: {
            runAsSudo: true,
            directory: '~/test/infoweb'
          }
        };
        p = tsk.runLocal(daNode, 'abc', {});
        fakeConn.emit('ready');
        return notifiesOnSuccess(p, done);
      });
      it('run-local should have invoked run underneath', function(){
        return spy.lastCall.args[1].should.be.equal('cd ~/test/infoweb && sudo abc');
      });
      return it('run-local safe should return a successful promise if command fails', function(done){
        unpatchConnect(['createConnection', 'connect', 'sendCommand']);
        fakeConn = newConnection();
        patchConnect('createConnection', function(){
          return {};
        });
        patchConnect('connect', function(){
          return fakeConn;
        });
        spy = patchConnect('sendCommand', function(){
          return createRejectedPromise();
        });
        p = tsk.runLocalSafe({}, 'a', {});
        fakeConn.ok();
        return notifiesOnSuccess(p, done);
      });
    });
    return describe('sequence', function(empty){
      var namespace, s1;
      namespace = {
        test: {
          tasks: {
            task1: {
              name: 'task1',
              fun: function(){
                var d;
                d = __q.defer();
                d.resolve('task finished');
                return d.promise;
              }
            },
            taskfail: {
              name: 'taskfail',
              fun: function(){
                var d;
                d = __q.defer();
                d.reject('task finished with error');
                return d.promise;
              }
            }
          }
        }
      };
      it('should execute a single task', function(done){
        var promise;
        s1 = sinon.spy(namespace['test'].tasks['task1'], 'fun');
        promise = tsk.sequence(namespace.test, 'task1');
        return notifiesOnSuccess(promise, done);
      });
      it('should execute only once the task', function(){
        return s1.calledOnce.should.be.equal(true);
      });
      it('should execute an array sequence', function(done){
        var promise;
        promise = tsk.sequence(namespace.test, ['task1', 'task1']);
        return notifiesOnSuccess(promise, done);
      });
      it('should execute an array sequence', function(){
        return s1.calledThrice.should.be.equal(true);
      });
      it('should not complete a sequence if a task fails', function(done){
        var promise;
        promise = tsk.sequence(namespace.test, ['taskfail', 'task1']);
        return notifiesOnFail(promise, done);
      });
      return it('should not execute a task after a failed one', function(){
        return s1.calledThrice.should.be.equal(true);
      });
    });
  });
  describe('ssh commands', function(empty){
    var s1, s2, s3, fakeProc, targetModule, nodes, result, command;
    targetModule = require('./ssh');
    nodes = {
      s1: {
        description: "Hbomb",
        path: {
          username: "zaccaria",
          hostname: "hbomb.elet.polimi.it",
          port: "22",
          credentials: '/Users/zaccaria/.ssh/id_rsa',
          hosttype: 'linux',
          access: 'ssh'
        }
      },
      s2: {
        description: "Vagrant box",
        path: {
          from: 's1',
          use: 4444,
          username: "vagrant",
          hostname: "127.0.0.1",
          port: "2222",
          credentials: '/Users/zaccaria/.ssh/id_rsa',
          hosttype: 'linux',
          access: 'ssh'
        }
      }
    };
    it('`module` should contain injectable methods', function(){
      should.exist(targetModule.innerModule().child_process.spawn);
      should.exist(targetModule.innerModule().shelljs);
      return should.exist(targetModule.innerModule().setupTemporaryDirectory);
    });
    it('`module` should invoke load correctly..', function(done){
      var promise;
      fakeProc = new (require('events').EventEmitter)();
      sinon.stub(targetModule.innerModule(), 'getCredentials', function(){
        return 'xyz';
      });
      s1 = sinon.stub(targetModule.innerModule(), 'setupTemporaryDirectory', function(){
        return 'pippo';
      });
      s2 = sinon.stub(targetModule.innerModule(), 'removeTemporaryDirectory', function(){});
      s3 = sinon.stub(targetModule.innerModule().shelljs, 'cat', function(){
        return " [ { \"data\"   :      1 } ] ";
      });
      sinon.stub(targetModule.innerModule().child_process, 'spawn', function(){
        command = arguments;
        return fakeProc;
      });
      promise = targetModule.load({
        from: 's1:abc',
        'in': nodes
      });
      result = {};
      promise = promise.then(function(it){
        return result = it;
      });
      fakeProc.emit('close');
      return notifiesOnSuccess(promise, done);
    });
    it('`module` should invoke tmp dir functions', function(){
      s1.calledOnce.should.be.equal(true);
      s2.calledOnce.should.be.equal(true);
      s3.calledOnce.should.be.equal(true);
      command[1][1].should.be.equal('set ftp:ssl-allow false; open ftp://zaccaria:xyz@hbomb.elet.polimi.it; get abc -o pippo/temp.json; bye;');
      should.exist(result);
      should.exist(result[0]);
      should.exist(result[0].data);
      return result[0].data.should.be.equal(1);
    });
    it('`module` should invoke read correctly and recognize errors..', function(done){
      var promise;
      fakeProc = new (require('events').EventEmitter)();
      promise = targetModule.load({
        from: 's1:abc',
        'in': nodes
      });
      result = {};
      promise = promise.then(function(it){
        return result = it;
      });
      fakeProc.emit('error');
      return notifiesOnFail(promise, done);
    });
    it('`module` should invoke save correctly..', function(done){
      var promise;
      fakeProc = new (require('events').EventEmitter)();
      sinon.stub(targetModule.innerModule().fs, 'writeFile', function(what, how, after){
        return after();
      });
      promise = targetModule.save({
        d: 1
      }, {
        to: 's2:abc',
        'in': nodes
      });
      fakeProc.emit('close');
      return notifiesOnSuccess(promise, done);
    });
    return it('should invoke tmp dir functions', function(){
      s1.calledThrice.should.be.equal(true);
      s2.calledThrice.should.be.equal(true);
      return command[1][1].should.be.equal('set ftp:ssl-allow false; open ftp://vagrant:xyz@127.0.0.1; put pippo/temp.json -o abc; bye;');
    });
  });
  function curry$(f, bound){
    var context,
    _curry = function(args) {
      return f.length > 1 ? function(){
        var params = args ? args.concat() : [];
        context = bound ? context || this : this;
        return params.push.apply(params, arguments) <
            f.length && arguments.length ?
          _curry.call(context, params) : f.apply(context, params);
      } : f;
    };
    return _curry();
  }
}).call(this);
