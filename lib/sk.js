// Generated by LiveScript 1.2.0
(function(){
  var _, moment, fs, color, os, shelljs, table, __q, winston, invokeActions, ref$, mountTunnel, unmountTunnel, printEnv, getInterestedNodes, dispOk, dispKo, disp, pdisp, pdeb, psetup, name, description, author, year, src, otm, cwd, usageString, optimist, argv, ff, nodes, namespace, e, ns, value, n, v, ok, ko, copy, original, current, i$, len$;
  _ = require('underscore');
  _.str = require('underscore.string');
  moment = require('moment');
  fs = require('fs');
  color = require('ansi-color').set;
  os = require('os');
  shelljs = require('shelljs');
  table = require('ansi-color-table');
  __q = require('q');
  winston = require('winston');
  invokeActions = require('../lib/actions').invokeActions;
  ref$ = require('../lib/tunnel'), mountTunnel = ref$.mountTunnel, unmountTunnel = ref$.unmountTunnel;
  printEnv = require('../lib/print').printEnv;
  getInterestedNodes = require('../lib/task').getInterestedNodes;
  dispOk = function(){
    return winston.info("Ok");
  };
  dispKo = function(it){
    return winston.error(it.toString());
  };
  disp = winston.info;
  pdisp = console.log;
  pdeb = winston.warn;
  psetup = function(file){
    if (file != null) {
      winston.add(winston.transports.File, {
        filename: file
      });
      return winston.remove(winston.transports.Console);
    } else {
      winston.remove(winston.transports.Console);
      return winston.add(winston.transports.Console, {
        level: 'info',
        colorize: true
      });
    }
  };
  _.mixin(_.str.exports());
  _.str.include('Underscore.string', 'string');
  name = "Swiss Knife 2.0 - Deploy Tool";
  description = "A remote deploy tool inspired by the Inception Movie";
  author = "Vittorio Zaccaria";
  year = "2013";
  src = __dirname;
  otm = os.tmpdir != null ? os.tmpdir() : "/var/tmp";
  cwd = process.cwd();
  usageString = "\n" + color(name, 'bold') + ". " + description + "\n(c) " + author + ", " + year + "\n\nUsage: " + name + " [--option=V | -o V] task(s) ";
  optimist = require('optimist');
  argv = optimist.usage(usageString, {
    help: {
      alias: 'h',
      description: 'This help'
    },
    logfile: {
      alias: 'g',
      description: 'Specify a log file'
    },
    list: {
      alias: 'l',
      description: 'List available tasks'
    },
    'default': {
      alias: 'd',
      description: 'Use default node'
    },
    command: {
      alias: 'c',
      description: 'Use with `cmd` task to specify a remote command'
    },
    file: {
      alias: 'f',
      description: 'Use this config file'
    },
    latency: {
      alias: 'y',
      description: 'Wait for latency (ms)'
    },
    namespace: {
      alias: 's',
      description: 'Namespace for tasks',
      'default': 'general'
    },
    node: {
      alias: 'n',
      description: 'Specify target node or a comma separated list (e.g., -n s1,s2,s3)'
    },
    tags: {
      alias: 't',
      description: 'Specify a tag list separated by commas'
    },
    aliases: {
      alias: 'z',
      description: 'dumps aliases for zsh, needs a -s'
    }
  }).boolean('l').boolean('d').boolean('z').argv;
  if (argv.help) {
    optimist.showHelp();
  }
  if (argv.file == null) {
    argv.file = "./config.js";
  }
  psetup(argv.logile);
  ff = require("path").resolve(cwd, argv.file);
  try {
    ref$ = require(ff), nodes = ref$.nodes, namespace = ref$.namespace;
  } catch (e$) {
    e = e$;
    dispKo("Sorry, no configuration file found: " + e);
    process.exit(0);
  }
  if (argv.aliases != null && argv.aliases) {
    for (ns in namespace) {
      value = namespace[ns];
      for (n in ref$ = namespace[ns].tasks) {
        v = ref$[n];
        console.log("alias " + ns + "-" + n + "='sk -f " + argv.file + " -s " + ns + " " + n + "'");
      }
    }
    process.exit(0);
  }
  if (argv.list != null && argv.list || argv.help != null && argv.help) {
    printEnv(nodes, namespace);
  }
  if (nodes['default'] == null || nodes[nodes['default']] == null) {
    dispKo("You should specify a default node");
    process.exit(0);
  }
  ok = function(it){
    dispOk(it);
    return process.exit();
  };
  ko = function(it){
    dispKo(it);
    return process.exit();
  };
  copy = function(x){
    var cmm;
    cmm = "echo '" + x + "' | pbcopy";
    return shelljs.exec(cmm);
  };
  original = __q.defer();
  current = original.promise;
  for (i$ = 0, len$ = (ref$ = getInterestedNodes(argv, nodes)).length; i$ < len$; ++i$) {
    n = ref$[i$];
    current = invokeActions(current, n, argv, nodes, namespace);
  }
  current.then(ok, ko);
  original.resolve();
}).call(this);
