// Generated by LiveScript 1.2.0
(function(){
  var _, moment, fs, color, ref$, spawn, kill, __q, sh, os, shelljs, cl, ut, winston, dispOk, dispKo, disp, pdisp, pdeb, _module, slice$ = [].slice;
  _ = require('underscore');
  _.str = require('underscore.string');
  moment = require('moment');
  fs = require('fs');
  color = require('ansi-color').set;
  ref$ = require('child_process'), spawn = ref$.spawn, kill = ref$.kill;
  __q = require('q');
  sh = require('shelljs');
  os = require('os');
  shelljs = sh;
  cl = require('clark');
  ut = require('utf-8');
  winston = require('winston');
  dispOk = function(){
    return winston.info("Ok");
  };
  dispKo = function(it){
    return winston.error(it.toString());
  };
  disp = winston.info;
  pdisp = console.log;
  pdeb = winston.warn;
  _.mixin(_.str.exports());
  _.str.include('Underscore.string', 'string');
  _module = function(){
    var innerModule, sequence, namespace, buildTasks, task, getInterestedNodes, bsh, zsh, createLocal, removeLocal, runLocalSafe, runLocal, run, iface;
    this.connect = require('./connect');
    innerModule = function(){
      return root;
    };
    sequence = function(context, args){
      var od, td, i$, len$, tt;
      if (_.isArray(args)) {
        od = __q.defer();
        td = od.promise;
        for (i$ = 0, len$ = args.length; i$ < len$; ++i$) {
          tt = args[i$];
          (fn$.call(this, tt, tt));
        }
        od.resolve(0);
        return td;
      } else {
        od = __q.defer();
        td = od.promise;
        td = td.then(function(){
          return (function(t){
            return context.tasks[t].fun.apply(context);
          }.call(this, args));
        });
        od.resolve(0);
        return td;
      }
      function fn$(t, tt){
        td = td.then(function(){
          return context.tasks[t].fun.apply(context);
        });
      }
    };
    namespace = function(){
      var a, name, description, tasks, n, opt, i$, ref$, len$, t, ns;
      a = arguments;
      name = a[0];
      description = '';
      tasks = {};
      n = 1;
      if (_.isString(a[n])) {
        description = a[n];
        n = n + 1;
      }
      opt = {};
      if (_.isObject(a[n]) && !(a[n].fun != null || a[n].description != null || a[n].name)) {
        opt = a[n];
        n = n + 1;
      }
      for (i$ = 0, len$ = (ref$ = slice$.call(a, n)).length; i$ < len$; ++i$) {
        t = ref$[i$];
        tasks[t.name] = t;
      }
      ns = {
        name: name,
        description: description,
        tasks: tasks
      };
      _.extend(ns, opt);
      return ns;
    };
    buildTasks = function(v){
      var ns, i$, len$, i;
      ns = {};
      for (i$ = 0, len$ = v.length; i$ < len$; ++i$) {
        i = v[i$];
        ns[i.name] = i;
      }
      return ns;
    };
    task = function(){
      var a, name, description, fun, n, show, ref$, ts;
      a = arguments;
      name = a[0];
      description = '';
      fun = undefined;
      n = 1;
      show = false;
      if (((ref$ = a[n]) != null ? ref$.show : void 8) != null) {
        show = a[n].show;
        n = n + 1;
      }
      if (_.isString(a[n])) {
        description = a[n];
        n = n + 1;
      }
      if (_.isFunction(a[n])) {
        fun = a[n];
      } else {
        throw "Sorry, " + a[n] + " is not a function";
      }
      ts = {
        name: name,
        description: description,
        fun: fun,
        show: show
      };
      return ts;
    };
    getInterestedNodes = function(argv, nodes){
      if (argv['default'] || !argv.node) {
        if (nodes['default'] != null) {
          return [nodes['default']];
        } else {
          return [];
        }
      } else {
        return _.words(argv.node, ',');
      }
    };
    bsh = function(cmd){
      return "bash -l -c '" + cmd + "'";
    };
    zsh = function(c){
      return "zsh -l -c '" + c + "'";
    };
    createLocal = function(remoteNode, options){
      var ref$, cm;
      if (((ref$ = remoteNode.login) != null ? ref$.directory : void 8) != null) {
        cm = "mkdir -p " + remoteNode.login.directory;
        cm = (function(){
          var ref$;
          switch (false) {
          case !(((ref$ = remoteNode.login) != null ? ref$.runAsSudo : void 8) != null && remoteNode.login.runAsSudo === true):
            return "sudo " + cm;
          case !((options != null ? options.runAsSudo : void 8) != null && (options != null ? options.runAsSudo : void 8) === true):
            return "sudo " + cm;
          default:
            return cm;
          }
        }());
        return run(remoteNode, cm);
      }
    };
    removeLocal = function(remoteNode, options){
      var ref$, cm;
      if (((ref$ = remoteNode.login) != null ? ref$.directory : void 8) != null) {
        cm = "rm -rf " + remoteNode.login.directory;
        cm = (function(){
          var ref$;
          switch (false) {
          case !(((ref$ = remoteNode.login) != null ? ref$.runAsSudo : void 8) != null && remoteNode.login.runAsSudo === true):
            return "sudo " + cm;
          case !((options != null ? options.runAsSudo : void 8) != null && (options != null ? options.runAsSudo : void 8) === true):
            return "sudo " + cm;
          default:
            return cm;
          }
        }());
        return run(remoteNode, cm);
      }
    };
    runLocalSafe = function(remoteNode, comms, options){
      var p, success, fail;
      p = runLocal(remoteNode, comms, options);
      success = function(it){
        return it;
      };
      fail = function(it){
        return it;
      };
      return p.then(success, fail);
    };
    runLocal = function(remoteNode, comms, options){
      var cm, cd, newCommands, sendingCommands, i$, len$, command, ref$;
      newCommands = [];
      sendingCommands = [];
      if (_.isString(comms)) {
        sendingCommands.push(comms);
      } else {
        sendingCommands = comms;
      }
      for (i$ = 0, len$ = sendingCommands.length; i$ < len$; ++i$) {
        command = sendingCommands[i$];
        cm = (fn$());
        cd = (fn1$());
        if (((ref$ = remoteNode.login) != null ? ref$.shell : void 8) != null && _.isFunction(remoteNode.login.shell)) {
          cd = remoteNode.login.shell(cd);
        }
        newCommands = newCommands.concat([cd]);
      }
      return run(remoteNode, newCommands, options);
      function fn$(){
        var ref$;
        switch (false) {
        case !(((ref$ = remoteNode.login) != null ? ref$.runAsSudo : void 8) != null && remoteNode.login.runAsSudo === true):
          return "sudo " + command;
        case !((options != null ? options.runAsSudo : void 8) != null && (options != null ? options.runAsSudo : void 8) === true):
          return "sudo " + command;
        default:
          return command;
        }
      }
      function fn1$(){
        var ref$;
        switch (false) {
        case !(((ref$ = remoteNode.login) != null ? ref$.directory : void 8) != null && (options != null ? options.subDir : void 8) != null):
          return "cd " + remoteNode.login.directory + "/" + options.subDir + " && " + cm;
        case ((ref$ = remoteNode.login) != null ? ref$.directory : void 8) == null:
          return "cd " + remoteNode.login.directory + " && " + cm;
        default:
          return cm;
        }
      }
    };
    run = function(remoteNode, command, options){
      var e, conn, shutdownOk, shutdownFail;
      e = __q.defer();
      pdeb("Entering `run`");
      conn = connect.createConnection();
      conn = connect.connect(conn, remoteNode);
      pdeb("Executing `run`");
      connect.registerMsgHandlers(conn, e);
      shutdownOk = function(it){
        conn.end();
        return e.resolve(it);
      };
      shutdownFail = function(it){
        conn.end();
        return e.reject(it);
      };
      conn.on('ready', function(){
        var od, td, i$, ref$, len$, c;
        pdeb("Ready to send command " + command);
        if (_.isArray(command)) {
          od = __q.defer();
          td = od.promise;
          for (i$ = 0, len$ = (ref$ = command).length; i$ < len$; ++i$) {
            c = ref$[i$];
            (fn$.call(this, c, c));
          }
          td.then(shutdownOk, shutdownFail);
          return od.resolve(0);
        } else {
          return connect.sendCommand(conn, command, options).then(shutdownOk, shutdownFail);
        }
        function fn$(cc, c){
          td = td.then(function(){
            pdeb("Sending command " + cc);
            return connect.sendCommand(conn, cc);
          });
        }
      });
      return e.promise;
    };
    iface = {
      innerModule: innerModule,
      sequence: sequence,
      namespace: namespace,
      buildTasks: buildTasks,
      bsh: bsh,
      run: run,
      runLocal: runLocal,
      runLocalSafe: runLocalSafe,
      task: task,
      getInterestedNodes: getInterestedNodes,
      createLocal: createLocal,
      removeLocal: removeLocal,
      zsh: zsh
    };
    return iface;
  };
  module.exports = _module();
}).call(this);
