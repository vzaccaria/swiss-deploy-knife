// Generated by LiveScript 1.2.0
(function(){
  var _, moment, color, __q, os, cl, ut, winston, dispOk, dispKo, disp, pdisp, pdeb, lftpScript, src, otm, cwd, surlGet, lftpScriptPut, lftpScriptGet, lftp_opts, lftpScriptMirror, _module, split$ = ''.split;
  _ = require('underscore');
  _.str = require('underscore.string');
  moment = require('moment');
  color = require('ansi-color').set;
  __q = require('q');
  os = require('os');
  cl = require('clark');
  ut = require('utf-8');
  winston = require('winston');
  dispOk = function(){
    return winston.info("Ok");
  };
  dispKo = function(it){
    return winston.error(it.toString());
  };
  disp = winston.info;
  pdisp = console.log;
  pdeb = winston.warn;
  _.mixin(_.str.exports());
  _.str.include('Underscore.string', 'string');
  lftpScript = function(us, pw, url){
    return "set ftp:ssl-allow false; open ftp://" + us + ":" + pw + "@" + url + ";";
  };
  src = __dirname;
  otm = os.tmpdir != null ? os.tmpdir() : "/var/tmp";
  cwd = process.cwd();
  surlGet = function(str){
    var ref$, nodeName, nodePath;
    ref$ = split$.call(str, ':'), nodeName = ref$[0], nodePath = ref$[1];
    if (nodePath == null) {
      nodePath = nodeName;
      nodeName = 'local';
    }
    return [nodeName, nodePath];
  };
  lftpScriptPut = function(us, pw, url, f, r){
    return "set ftp:ssl-allow false; open ftp://" + us + ":" + pw + "@" + url + "; put " + f + " -o " + r + "; bye;";
  };
  lftpScriptGet = function(us, pw, url, f, r){
    return "set ftp:ssl-allow false; open ftp://" + us + ":" + pw + "@" + url + "; get " + f + " -o " + r + "; bye;";
  };
  lftp_opts = "--reverse --ignore-time --verbose=1 --use-cache --allow-chown --allow-suid --no-umask --parallel=2 --exclude-glob .svn";
  lftpScriptMirror = function(us, pw, url, f, t){
    return "set ftp:ssl-allow false; open ftp://" + us + ":" + pw + "@" + url + "; mirror " + lftp_opts + " " + f + " " + t + "; bye;";
  };
  _module = function(){
    var scope, append, openTerminal, mirror, getAsSftpNode, load, save, innerModule, init, iface;
    this.child_process = require('child_process');
    this.shelljs = require('shelljs');
    this.cnn = require('./connect');
    this.fs = require('fs');
    this.setupTemporaryDirectory = function(){
      var name, dire;
      name = "tmp_" + moment().format('HHmmss') + "_tmp";
      dire = otm + "/" + name;
      shelljs.mkdir('-p', dire);
      return dire;
    };
    this.removeTemporaryDirectory = function(dir){
      return shelljs.rm('-rf', dir);
    };
    this.getCredentials = function(credentials, url, user){
      return require(credentials)[url][user];
    };
    append = function(value, options){
      var combine, opt, logt, p;
      combine = function(it){
        switch (false) {
        case !_.isArray(it):
          return it.concat([value]);
        default:
          return [it, value];
        }
      };
      opt = {
        from: options.to,
        'in': options['in']
      };
      logt = function(it){
        console.log(JSON.stringify(it, null, 4));
        return it;
      };
      p = load(opt).then(logt).then(combine).then(logt).then(function(it){
        return save(it, options);
      });
      return p.fail(function(){
        return save(value, options);
      });
    };
    openTerminal = function(address){
      var d, args, ch2, us, url, pw, cc;
      d = __q.defer();
      if (address.access === 'ssh') {
        args = [address.username + "@" + address.hostname, "-p", address.port + ""];
        pdeb("Executing command `ssh` " + args[0] + ", " + args[1] + ", " + args[2]);
        ch2 = child_process.spawn('ssh', args, {
          stdio: 'inherit'
        });
        ch2.on('error', function(){
          return d.reject("Failed connection");
        });
        ch2.on('close', function(){
          return d.resolve("Exited from command line.");
        });
        return d.promise;
      }
      if (address.access === 'ftp') {
        us = address.username;
        url = address.hostname;
        pw = getCredentials(address.credentials, url, us);
        args = ["-e", lftpScript(us, pw, url)];
        pdeb("Executing command `lftp` " + args[0] + ", " + args[1]);
        cc = child_process.spawn('lftp', args, {
          stdio: 'inherit'
        });
        cc.on('error', function(){
          return d.reject("Failed connection");
        });
        cc.on('close', function(){
          return d.resolve('Exited from ftp');
        });
        return d.promise;
      }
      d.reject("Invalid " + address.access + " specified as access mode.");
      return d.promise;
    };
    mirror = function(options){
      var d, ref$, local, frm, node, dirname, ref1$, nn, us, url, pw, args, cc;
      d = __q.defer();
      if (options.from == null || options.to == null || options['in'] == null) {
        d.reject("Sorry, invalid options for save");
      } else {
        ref$ = split$.call(options.from, ':'), local = ref$[0], frm = ref$[1];
        ref$ = split$.call(options.to, ':'), node = ref$[0], dirname = ref$[1];
        if (local !== 'local') {
          d.reject("Sorry, mirror at the moment accepts only one remote destination");
          return d.promise;
        }
        if (((options != null ? (ref$ = options['in']) != null ? (ref1$ = ref$[node]) != null ? (ref$ = ref1$.path) != null ? ref$.access : void 8 : void 8 : void 8 : void 8) == null) === 'ftp') {
          d.reject("Sorry, " + node + " does not exist or it does not have ftp access");
        } else {
          nn = options['in'][node].path;
          us = nn.username;
          url = nn.hostname;
          pw = getCredentials(nn.credentials, url, us);
          args = ["-e", lftpScriptMirror(us, pw, url, frm, dirname)];
          pdeb("Executing command `lftp` " + args[0] + ", " + args[1]);
          cc = child_process.spawn('lftp', args, {
            stdio: 'inherit'
          });
          cc.on('error', function(){
            return d.reject("Failed connection");
          });
          cc.on('close', function(){
            return d.resolve('Exited from ftp');
          });
        }
      }
      return d.promise;
    };
    getAsSftpNode = function(node, data){
      if (data[node] == null || !data[node].path.access === 'ftp') {
        return null;
      } else {
        return data[node].path;
      }
    };
    load = function(options){
      var d, ref$, node, filename, nodeCoords, us, url, dd, pw, args, cc, dta, data;
      d = __q.defer();
      if (options['in'] == null || options.from == null) {
        d.reject("Sorry, invalid options for load");
      } else {
        ref$ = surlGet(options.from), node = ref$[0], filename = ref$[1];
        if (node !== 'local') {
          nodeCoords = getAsSftpNode(node, options['in']);
          if (nodeCoords == null) {
            d.reject("Sorry, " + node + " does not exist or it does not have ftp access");
          } else {
            us = nodeCoords.username;
            url = nodeCoords.hostname;
            dd = setupTemporaryDirectory();
            pw = getCredentials(nodeCoords.credentials, url, us);
            args = ["-e", lftpScriptGet(us, pw, url, filename, dd + "/temp.json")];
            cc = child_process.spawn('lftp', args);
            cc.on('error', function(){
              removeTemporaryDirectory(dd);
              return d.reject("Failed connection");
            });
            cc.on('close', function(){
              var dta, data, error;
              dta = shelljs.cat(dd + "/temp.json");
              removeTemporaryDirectory(dd);
              try {
                data = JSON.parse(dta);
              } catch (e$) {
                error = e$;
                d.reject(error);
              }
              return d.resolve(data);
            });
          }
        } else {
          dta = shelljs.cat(filename);
          data = JSON.parse(dta);
          d.resolve(data);
        }
      }
      return d.promise;
    };
    save = function(what, options){
      var d, ref$, node, filename, nodeCoords, dd, dirn, txt;
      d = __q.defer();
      if (options['in'] == null || options.to == null) {
        d.reject("Sorry, invalid options for save");
      } else {
        ref$ = surlGet(options.to), node = ref$[0], filename = ref$[1];
        pdeb("Saving to " + node + " - " + filename);
        if (node !== 'local') {
          nodeCoords = getAsSftpNode(node, options['in']);
          if (nodeCoords == null) {
            d.reject("Sorry, " + node + " does not exist or it does not have ftp access");
          } else {}
          disp("Saving output to ftp://" + nodeCoords.hostname + ":" + filename);
          dd = setupTemporaryDirectory();
          fs.writeFile(dd + "/temp.json", what, function(err){
            var us, url, pw, args, cc;
            if (err) {
              d.reject("Problems writing " + dd + "/temp.json");
              return;
            }
            us = nodeCoords.username;
            url = nodeCoords.hostname;
            pw = getCredentials(nodeCoords.credentials, url, us);
            args = ["-e", lftpScriptPut(us, pw, url, dd + "/temp.json", filename)];
            cc = child_process.spawn('lftp', args);
            cc.on('error', function(){
              removeTemporaryDirectory(dd);
              return d.reject("Failed connection");
            });
            return cc.on('close', function(){
              removeTemporaryDirectory(dd);
              return d.resolve('Exited from ftp');
            });
          });
        } else {
          dirn = filename;
          txt = what.text;
          txt.to(dirn + "/" + what.filename);
          d.resolve("Saved to file");
        }
      }
      return d.promise;
    };
    innerModule = function(){
      return root;
    };
    init = function(data){
      return scope = data;
    };
    iface = {
      innerModule: innerModule,
      load: load,
      save: save,
      append: append,
      mirror: mirror,
      openTerminal: openTerminal
    };
    return iface;
  };
  module.exports = _module();
}).call(this);
