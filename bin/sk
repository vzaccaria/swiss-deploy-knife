#!/usr/bin/env node
(function(){
  var _, moment, fs, color, os, shelljs, table, name, description, author, year, src, otm, cwd, setupTemporaryDirectory, usageString, optimist, argv, ref$, nodes, namespace, tab, nsf, tf, ns, nns, vns, k, v, data, __q, invokeActions, ok, ko, original, current, i$, len$, n;
  _ = require('underscore');
  _.str = require('underscore.string');
  moment = require('moment');
  fs = require('fs');
  color = require('ansi-color').set;
  os = require('os');
  shelljs = require('shelljs');
  table = require('ansi-color-table');
  _.mixin(_.str.exports());
  _.str.include('Underscore.string', 'string');
  name = "Swiss Knife 2.0 - Deploy Tool";
  description = "A remote deploy tool inspired by the Inception Movie";
  author = "Vittorio Zaccaria";
  year = "2013";
  src = __dirname;
  otm = os.tmpdir != null ? os.tmpdir() : "/var/tmp";
  cwd = process.cwd();
  setupTemporaryDirectory = function(){
    var name, dire;
    name = "tmp_" + moment().format('HHmmss') + "_tmp";
    dire = otm + "/" + name;
    shelljs.mkdir('-p', dire);
    return dire;
  };
  usageString = "\n" + color(name, 'bold') + ". " + description + "\n(c) " + author + ", " + year + "\n\nUsage: " + name + " [--option=V | -o V] task(s) ";
  optimist = require('optimist');
  argv = optimist.usage(usageString, {
    help: {
      alias: 'h',
      description: 'This help'
    },
    list: {
      alias: 'l',
      description: 'List available tasks'
    },
    'default': {
      alias: 'd',
      description: 'Use default node'
    },
    command: {
      alias: 'c',
      description: 'Use with `cmd` task to specify a remote command'
    },
    file: {
      alias: 'f',
      description: 'Use this config file'
    },
    node: {
      alias: 'n',
      description: 'Specify target node or a comma separated list (e.g., -n s1,s2,s3)'
    }
  }).boolean('l').boolean('d').argv;
  if (argv.help) {
    optimist.showHelp();
  }
  ref$ = require(cwd + "/" + argv.file), nodes = ref$.nodes, namespace = ref$.namespace;
  tab = 25;
  nsf = function(s){
    return _.pad('', 2) + _.rpad(color(s, 'bold'), tab - 2);
  };
  tf = function(s){
    return _.pad(':', 10) + _.rpad(s, tab - 20 + 2);
  };
  if (argv.list != null && argv.list || argv.help != null && argv.help) {
    console.log("Namespace and tasklist:");
    console.log("");
    ns = namespace;
    for (nns in ns) {
      vns = ns[nns];
      console.log(nsf(nns), " — " + vns.description);
      for (k in ref$ = vns.tasks) {
        v = ref$[k];
        console.log(tf(k), " — " + v.description);
      }
      console.log("");
    }
    console.log("Nodes:");
    console.log("");
    for (name in nodes) {
      data = nodes[name];
      if (name !== 'default') {
        console.log(nsf(name), " — ", data.description, "[", color(data.access, 'green'), "]");
      }
    }
    return 0;
  }
  if (nodes['default'] == null || nodes[nodes['default']] == null) {
    console.log("You should specify a default node");
    return;
  }
  __q = require('q');
  invokeActions = function(p, tt){
    var ref$, createTunnel, closeTunnel, target, i$, len$, t, taskFunction, context, address, through, newContext;
    if (nodes[tt] == null) {
      return p.thenReject("Skipping " + tt + ", invalid target ");
    }
    if (argv._.length === 0) {
      return p.thenReject("Pleas specify at least one task");
    }
    ref$ = require('../lib/sk-lib'), createTunnel = ref$.createTunnel, closeTunnel = ref$.closeTunnel;
    target = nodes[tt];
    for (i$ = 0, len$ = (ref$ = argv._).length; i$ < len$; ++i$) {
      t = ref$[i$];
      if (in$(t, _.pluck(namespace['general'].tasks, 'name'))) {
        if (target.path.from == null) {
          console.log("Launching `" + t + "` on `" + target.path.hostname + "`");
          taskFunction = namespace['general'].tasks[t].fun;
          context = {
            local: target.path,
            args: argv
          };
          p = p.then(fn$);
        } else {
          address = target.path;
          through = nodes[target.path.from].path;
          console.log("Launching `" + t + "` on `" + address.hostname + ":" + address.port + "` through `" + through.hostname + "`");
          taskFunction = namespace['general'].tasks[t].fun;
          newContext = {
            local: {
              username: address.username,
              hostname: "localhost",
              port: address.use,
              credentials: address.credentials
            },
            args: argv
          };
          p = p.then(fn1$);
          p = p.then(fn2$);
          p = p.then(fn3$);
        }
      } else {
        return p.thenReject("Sorry, no valid task named " + t);
      }
    }
    return p;
    function fn$(){
      return taskFunction.apply(context);
    }
    function fn1$(){
      return createTunnel(address, through);
    }
    function fn2$(){
      return taskFunction.apply(newContext);
    }
    function fn3$(){
      return closeTunnel();
    }
  };
  ok = function(){
    console.log(color("Ok", 'green'));
    return process.exit();
  };
  ko = function(it){
    console.log(color("Error:", "red"), it);
    return process.exit();
  };
  original = __q.defer();
  current = original.promise;
  if (argv['default']) {
    if (nodes['default'] != null) {
      current = invokeActions(current, nodes['default']);
    } else {
      current = current.thenReject("Please specify a default node");
    }
  }
  for (i$ = 0, len$ = (ref$ = _.words(argv.node, ',')).length; i$ < len$; ++i$) {
    n = ref$[i$];
    current = invokeActions(current, n);
  }
  current.then(ok, ko);
  original.resolve();
  function in$(x, arr){
    var i = -1, l = arr.length >>> 0;
    while (++i < l) if (x === arr[i] && i in arr) return true;
    return false;
  }
}).call(this);
